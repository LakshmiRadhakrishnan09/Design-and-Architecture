## ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ ğ—¦ğ˜‚ğ—¿ğ˜ƒğ—¶ğ˜ƒğ—®ğ—¹ ğ—šğ˜‚ğ—¶ğ—±ğ—² (ğŸ®ğŸ¬ğŸ®ğŸ¯): ğ—£ğ—¿ğ—²ğ—½ğ—®ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¦ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ—¶ğ—²ğ˜€ ğ—®ğ—»ğ—± ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—®ğ—¹ ğ—§ğ—¶ğ—½ğ˜€

https://www.linkedin.com/feed/update/urn:li:activity:7127988626730217472?updateEntityUrn=urn%3Ali%3Afs_updateV2%3A%28urn%3Ali%3Aactivity%3A7127988626730217472%2CFEED_DETAIL%2CEMPTY%2CDEFAULT%2Cfalse%29


Here is an outline of the preparation strategies and practical tips for acing a system design interview:

## ğ—™ğ˜‚ğ—»ğ—±ğ—®ğ—ºğ—²ğ—»ğ˜ğ—®ğ—¹ğ˜€ ğ—¼ğ—³ ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—»

## Scalability (https://www.designgurus.io/blog/grokking-system-design-scalability)
              Ability of a system to handle an increasing workload, both in terms of data volume and user requests, without compromising its performance. 
Vertical Scaling : Adding more capacity of one machine(increase CPU , memory or storage) 
Horizontal Scaling: Add more servers. Can add or remove based on need(More flexible). Upgrades will not cause down time. Need a Load balancer to distribute the requests. Distributed caching and distributed databases.
Load Balancing: 
Asynchronous Processing (Decoupled services)
Distributed databases ( with sharding , partioning and replication): Need to take care of data consistency.
Distributed Caching ( to reduce db reads)
Geo-distribution ( keep the data close to user)
Microservice Architecture: breaking down your system into smaller, independently deployable services that communicate via APIs. 
By adopting a microservices architecture, you can achieve greater flexibility and scalability, as each service can be developed, deployed, and scaled independently. 
Data compression

In AWS: LoadBalancer(ALB) for ur Ec2 instances and ASG. 
Read: How EKS do load balancing
How ECS do load balancing
## Fault tolerance
## Load balancing
## Caching : CDNs
## Availability
## Consistency
## Resiliency: capable of recovering from failures and continuing to operate under adverse conditions. Redundancy, fault tolerance, and automated failover mechanisms. 
Chaos Testing: Inject failures in system to identify weakness.
* Latency
* Throughput
* Partition Tolerance
* CAP Theorem
* ACID Properties
* Monitoring Tools
      Collect Metrics on response times, error rates, and resource utilization.

## ğ—¨ğ—»ğ—±ğ—²ğ—¿ğ˜€ğ˜ğ—®ğ—»ğ—± ğ—°ğ—¼ğ—ºğ—ºğ—¼ğ—» ğ—±ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—½ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€
Microservices
## Sharding :  Splits a database into smaller, more manageable pieces. Eg: Shard by location, shrad by first letter of name.
Selecting the right shard key is crucial. Some shards can become hotspots. Most of the query to a single shrad.
If data is in different shrads, it may result in cross-shard query which result in increased latency. Query patterns need to decide the shrad key.
Reshrading or redistribuing data is difficult.
## Event sourcing
Circuit Breaker
Reverse proxy
Backpressure
CQRS (Command Query Responsibility Segregation)
Object Pool

ğŸ¯) ğ—™ğ—®ğ—ºğ—¶ğ—¹ğ—¶ğ—®ğ—¿ğ—¶ğ˜ğ˜† ğ˜„ğ—¶ğ˜ğ—µ ğ—±ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ˜ ğ˜ğ˜†ğ—½ğ—²ğ˜€ ğ—¼ğ—³ ğ—±ğ—®ğ˜ğ—®ğ—¯ğ—®ğ˜€ğ—²ğ˜€
Relational databases
NoSQL databases
Distributed key-value stores
Document databases
Graph databases
Time-series databases

Why is it hard to horizontally scale(shrading) SQL databases? 
Due to relationships between data and ACID properties for transactions.
**Atomicity**: Each transaction is all or nothing. If one part of transaction fails, then whole transaction fails. 
In a distributed system it is difficult to coordinate the transactions across multiple nodes and to rollback transactions in case of partial failures. 
It needs two phase commit. 
**Consistency**: Transactions change the system from one valid state to another and all constaints are valid. Need distributed locks and consensus algorithm.
**Isolation**: Concurrent transactions occur as if they are happening sequentially.
**Durability**: Data once committed is saved for ever.
Introduce network latency as shrads can be in different servers.
Joins across multiple shards, Transactions across multiple shards, Maintaining constraints like foreign key, unique key are difficult in a distributed system.

Consistency in ACID and consistency in CAP refers to different consistency. 

Atomic Consistency(in CAP theorem) ensures that all processing units(nodes or threads) see the same updates in the same order as if they were made by a single processing unit. 
It guarantees that updates made by one processing unit are immediately visible to all other processing units. 

Tradeoff : Consistency vs Performance/Availability. 

To mitigate issues with shrading: Application level Sharding, Consistent Hashing, Database Middleware, Denormalization, Polygot Persistence, Geo-Partitioning

Before taking on a project as big as sharding, itâ€™s often best to first ensure you have a sound foundation upon which you plan to extend the architecture. 

ğŸ°) ğ—™ğ—®ğ—ºğ—¶ğ—¹ğ—¶ğ—®ğ—¿ğ—¶ğ˜ğ˜† ğ˜„ğ—¶ğ˜ğ—µ ğ—±ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ˜ ğ˜ğ˜†ğ—½ğ—²ğ˜€ ğ—¼ğ—³ ğ—±ğ—¶ğ˜€ğ˜ğ—¿ğ—¶ğ—¯ğ˜‚ğ˜ğ—²ğ—± ğ˜€ğ˜†ğ˜€ğ˜ğ—²ğ—ºğ˜€ ğ—®ğ—»ğ—± ğ—®ğ—¹ğ—´ğ—¼ğ—¿ğ—¶ğ˜ğ—µğ—ºğ˜€
Merkle Tree
Consistent Hashing
Read Repair
Gossip Protocol
Bloom Filter
Heartbeat
CAP and PACELC Theorems

Two phase commit protocol

ğŸ±) ğ—Ÿğ—²ğ—®ğ—¿ğ—» ğ—µğ—¼ğ˜„ ğ˜ğ—¼ ğ—°ğ—¼ğ—ºğ—ºğ˜‚ğ—»ğ—¶ğ—°ğ—®ğ˜ğ—² ğ˜†ğ—¼ğ˜‚ğ—¿ ğ˜ğ—µğ—¼ğ˜‚ğ—´ğ—µğ˜ ğ—½ğ—¿ğ—¼ğ—°ğ—²ğ˜€ğ˜€
Start with the problem statement
Break down the problem
Use diagrams and sketches
Discuss trade-offs and constraints
Explain your reasoning
Be prepared to answer questions and provide alternatives
Be open to feedback

ğŸ²) ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—®ğ—»ğ˜€ğ˜„ğ—²ğ—¿ ğ—® ğ˜€ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ—±ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—¾ğ˜‚ğ—²ğ˜€ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ—®ğ—» ğ—¶ğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„?
Step 1: Requirements clarification
Step 2: Back-of-the-envelope estimation
Step 3: System interface definition
Step 4: Defining the data model
Step 5: High-level design
Step 6: Detailed design
Step 7: Identifying and resolving bottlenecks

ğŸ³) ğ—§ğ—¼ğ—½ ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ ğ—¤ğ˜‚ğ—²ğ˜€ğ˜ğ—¶ğ—¼ğ—»ğ˜€
## Design Facebook Messenger
https://bytebytego.com/courses/system-design-interview/design-a-chat-system

## Generating a unique Id
GUID: nearly guaranteed to be unique. 128 bits long. 32 hex digit.  
eg: 30dd879c-ee2f-11db-8314-0800200c9a66 (8â€“4â€“4â€“4â€“12)
But problem with GUIDs are that there can be collisions howsoever minuscule that probability is.
Other problems: They are longer( we may need shorter guids. Longer keys cannot be indexed). They are not sortable. 
The SQL auto increment sequence id - Results in single point of failure. We cannot scale it. If we use two servers, then it will not become sortable.

How others are solving this problem? - https://aaronice.gitbook.io/system-design/architecture-toolbox/id-generator?source=post_page-----d6a440cc8e5--------------------------------#single-machine

Flickr Ticket Service(https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)
* Generate unique sortable keys at scale.
* Flickr use a single database to generate uniqueId. SELECT * from Tickets64 returns a single row with latest Id. To compensate single point of failure, two servers are used one for generating odd ids and another for even ids. It generate unique ids but they are not sortable.
Twitter Snowflake(https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake) 
* Final ID = Timestamp + ServerID + Counter
Use Zookeeper for coordination
Zookeeper Sequential nodes : performance issues
Instagram(https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c)


## Design Youtube

Design Facebookâ€™s Newsfeed
Design an API Rate Limiter
Design Twitter
Design Dropbox or Google Drive
Design a Web Crawler
Design Twitter Search
Design a URL Shortening service like TinyURL
Design Instagram
Designing Yelp or Nearby Friends
Design Ticketmaster
Design Netflix
        CDNs

Ref:
âœ…ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ ğ—¦ğ˜‚ğ—¿ğ˜ƒğ—¶ğ˜ƒğ—®ğ—¹ ğ—šğ˜‚ğ—¶ğ—±ğ—² (ğŸ®ğŸ¬ğŸ®ğŸ¯) -
https://lnkd.in/deqz6gnz
âœ…Take a look at ğ—šğ—¿ğ—¼ğ—¸ğ—¸ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ for system design interview questions - https://lnkd.in/giwyzfkT
âœ…To learn software architecture and practice advanced system design interview questions take a look at ğ—šğ—¿ğ—¼ğ—¸ğ—¸ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ—°ğ—²ğ—± ğ—¦ğ˜†ğ˜€ğ˜ğ—²ğ—º ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ - https://lnkd.in/grPz6meZ

ğŸ“Œ Become Design Gurus affiliate and earn 20% on each referral: https://lnkd.in/gz4rqr5k

https://www.designgurus.io/blog

Read more
https://aaronice.gitbook.io/system-design/architecture-toolbox/id-generator?source=post_page-----d6a440cc8e5--------------------------------#single-machine

